pragma solidity ^0.4.13;

/**
 * blocksoft.biz antifake demo
 */

contract HouseStructure {
	
	struct DataFirstStep {
		string water;
		string datetime;
		uint8 latitude;
		uint8 latitudeDrop;
		uint8 longitude;
		uint8 longitudeDrop;
		uint z;
	}

	struct DataSecondStep {
		string datetime;
		uint8 latitude;
		uint8 latitudeDrop;
		uint8 longitude;
		uint8 longitudeDrop;
		uint z;
	}
}

contract House is HouseStructure {
 
	uint8 constant STATUS_ADDED = 1;
	uint8 constant STATUS_REGISTERED = 2;	
	address public owner; //address who can update random
	address public admin; //address who can ask random
	string userAdress;
    string _owner;
	string _architector;

	event ErrorEvent(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function error(uint current_step,uint newstep) payable {
        // Any call to this function (even deeply nested) can
        // be detected from the JavaScript API by filtering
        // for `Deposit` to be called.
        ErrorEvent(msg.sender, current_step, newstep);
    }
	
	function House() {
		owner = msg.sender;
		step = -2;
	}

	function() {
		revert();
	}

	modifier onlyOwner {
		if (msg.sender != owner) {
			revert();
		}
		_;
	}

	//random suggest structure
	 
	string githuburl; //random is generated by the seed

	//indexed suggests storage
	mapping ( uint => DataSecondStep ) geometryFirstStep;
	mapping ( uint => DataFirstStep  ) firstDataStep;
	mapping ( uint => DataSecondStep ) secondStep;
	mapping ( uint => DataSecondStep ) thirdStep;
	mapping ( uint => DataSecondStep ) fourStep;
	mapping ( uint => DataSecondStep ) fiveStep;
	mapping ( uint => DataSecondStep ) sixStep;

	uint public firstDataCount;
	uint public geometryDataCount;
	uint public secondStepCount;
	uint public thirdStepCount;
	uint public fourStepCount;
	uint public fiveStepCount;
	uint public sixStepCount;
	uint public step;

	function getGitCall() onlyOwner returns(bool) {
		 return githuburl;
	}

	function check(uint value) internal returns(bool) {
		if (step != value) {
			error(step, value);
			return false;
		}
		return true;
		step++;
	}

	function zeroZeroStepCall (string owner, string architector) onlyOwner returns(bool) {
		if (check(-2)) { 
			 _owner = owner;
			 _architector = architector;
			return true;
		}
		return false;
	}

	function zeroStepCall(string gitHubUrl) onlyOwner returns(bool) {
		if (check(-1)) { 
			githuburl = gitHubUrl;
			return true;
		}
		return false;
	}

	function SetGeometryFirstStep(string datetime,
		uint8 latitude,
		uint8 latitudeDrop,
		uint8 longitude,
		uint8 longitudeDrop,
		uint z) {
		    geometryFirstStep[geometryDataCount] =  DataSecondStep (
			datetime,
			latitude,
			latitudeDrop,
			longitude,
			longitudeDrop, z);
	}

	
	function compareDataFirstStep (DataSecondStep first, DataFirstStep second) onlyOwner returns(bool) {
			return first.datetime == second.datetime &&
			first.latitude == second.latitude &&
			first.latitudeDrop == second.latitudeDrop &&
			first.longitude == second.longitude &&
			first.longitudeDrop == second.longitudeDrop && 
			first.z == second.z;
	}
	
	function compareDataSecondStep (DataSecondStep first, DataSecondStep second) onlyOwner returns(bool) {
			return first.datetime == second.datetime &&
			first.latitude == second.latitude &&
			first.latitudeDrop == second.latitudeDrop &&
			first.longitude == second.longitude &&
			first.longitudeDrop == second.longitudeDrop && 
			first.z == second.z;
	}

	function firstStepCall(uint water, string datetime,
		uint8 latitude,
		uint8 latitudeDrop,
		uint8 longitude,
		uint8 longitudeDrop,
		uint z) onlyOwner returns(bool) {
		if (check(1)) { 
			firstDataStep[firstDataCount] = new DataFirstStep (water,
			datetime,
			latitude,
			latitudeDrop,
			longitude,
			longitudeDrop, z);
			firstDataCount++;
		}
		return false;
	}

	function secondStepCall(string gitHubUrl) onlyOwner returns(bool) {
		if (check(2)) { 
			githuburl = gitHubUrl;
			return true;
		}
		return false;
	}

	function thirdStepCall(string gitHubUrl) onlyOwner returns(bool) {
		if (check(3)) { 
			githuburl = gitHubUrl;
			return true;
		}
		return false;
	}

	function fourStepCall(string gitHubUrl) onlyOwner returns(bool) {
		if (check(4)) { 
			githuburl = gitHubUrl;
			return true;
		}
		return false;
	}

	function fiveStepCall(string gitHubUrl) onlyOwner returns(bool) {
		if (check(5)) { 
			githuburl = gitHubUrl;
			return true;
		}
		return false;
	}

	function sixStepCall(string gitHubUrl) onlyOwner returns(bool) {
		if (check(6)) { 
			githuburl = gitHubUrl;
			return true;
		}
		return false;
	}
	
	//place suggest of random number
	function placeDataFirstStep(string datetime,
		uint8 latitude,
		uint8 latitudeDrop,
		uint8 longitude,
		uint8 longitudeDrop,
		uint z) onlyOwner returns (uint placed) {
		
	}

	//something to review our db of suggested randoms
	function placeDataFirstStep(uint index) onlyOwner returns (bytes32 a, bool b, uint c) {
	 
	}

	//admin matched suggest with request in main contract (can call also here)
	function updateSuggestIndex(uint index, uint main_index) onlyOwner returns (bool) {
		if (suggests[index].asked) {
			revert();
		}
		suggests[index].index = main_index;
		suggests[index].asked = true;
	}

	//indexed requests storage
	mapping (bytes32 => uint8) items;

	//add item from manufacturer
	function addItem(bytes32 pubkey) public returns (bool) {
		if (msg.sender != owner) {
			revert();
		}
		items[pubkey] = STATUS_ADDED;
		return true;
	}

	//check item by customer
	function checkItem(bytes32 pubkey) constant returns (uint8 a) {
		a = items[pubkey];
	}

	//update item by customer
	function updateItem(bytes32 pubkey, bytes32 secret) returns (bool) {
		 
		 
		return true;
	}
}